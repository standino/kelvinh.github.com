#+TITLE:       Database Migration
#+AUTHOR:      Will Chang
#+EMAIL:       changewei.cn@gmail.com
#+DATE:        2013-12-19 Thu
#+URI:         /wiki/html/databasemigration
#+KEYWORDS:    db2
#+TAGS:        :db2:
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION:  Database Migration 


* Agenda

 - The Problems of database migration.
 - How ruby on rails handle the table changes
 - How our team to handle the database changes

* A good book

[[databasemigration1.png]]

* DRY---Don't Repeat Yourself

Every piece of knowledge must have a single, unambiguous, 
authoritative representation within a system.

* Our Problems

Agile requires us to embrace changes, but:

 1. It is difficult to get the change sets of the release.
 2. It is difficult to get the dependence between web and ods.
 3. If we need reload a table or UDF, we must drop the related UDF first.
 4. We can not roll back table or stored procedure easily.
 5. It is difficult to prepare replication change request.
 6. It is difficult to identify which stored procedure will be  impacted by a specific CR.

* Ruby on Rails

The design of Rails was driven by a couple of key concepts: DRY and convention over configuration.

Rails uses the power of Ruby to bring that to life. You'll find very little duplication in a Rails application; you say what
you need to say in one place-a place often suggested by the conventions of
the MVC architecture-and then move on. For programmers used to other
web frameworks, where a simple change to the schema could involve them
in half-a-dozen or more code changes, this was a revelation.

* Rails---What are migrations?

ActiveRecordMigration allows you to use Ruby to define changes to your database schema, making it possible to use a version control system to keep things synchronized with the actual code.

This has many uses, including:

    -  Teams of developers - if one person makes a schema change, the other developers just need to update, and run "rake db:migrate".
    -  Production servers - run "rake db:migrate" when you roll out a new release to bring the database up to date as well.
    -  Multiple machines - if you develop on both a desktop and a laptop, or in more than one location, migrations can help you keep them all synchronized.

* Rails---Create the migration

Run the generator:

<#+BEGIN_SRC ">
ruby script/generate migration add_a_new_table
</#+BEGIN_SRC >


This will create the file db/migrate/001_add_a_new_table.rb

* Rails---Edit the code to tell it what to do

The method self.up is used when migrating to a new version, self.down is used to roll back any changes if needed. 
<#+BEGIN_SRC ">
  class AddANewTable < ActiveRecord::Migration
    def self.up
      create_table :users do |table|
        table.column :name, :string
        table.column :password, :string, :limit => 32, :null => false
       end
    end
    def self.down
      drop_table :users
    end
 end
</#+BEGIN_SRC >



* Rails---Run the migration

There is a table in database to track the version.

<#+BEGIN_SRC >
rake db:migrate
</#+BEGIN_SRC >

<#+BEGIN_SRC >
rake db:migrate VERSION=17
</#+BEGIN_SRC >

* Our solution---Improvement, Not revolution
1) *Change Set*

Copy the changed files since the last release. 

2)  *Dependence and impacted store procedure*

Using shell script to query the catalog table to get the relationship of the DB object.

3) *Rollback and table changes*

It is not very necessary to support rollback. Use alter to change the table.
