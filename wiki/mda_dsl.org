#+TITLE:       MDA vs DSL
#+AUTHOR:      Will Chang
#+EMAIL:       changwei.cn@gmail.com
#+DATE:        2013-12-19 Thu
#+URI:         /wiki/mdadsl
#+KEYWORDS:    mda,dsl
#+TAGS:        :mda:dsl:
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION:  MDA vs DSL


* Pain Points of Software Development 
 1. Productivity
 2. Portability
 3. Interoperability
 4. Maintenance and Documentation  

* [[http://en.wikipedia.org/wiki/Model-driven_architecture][MDA Introduction]]

Model Driven Software Development (MDSD) is a style of software
development that considers itself as an alternative to the traditional
style of programming. 

The approach centers itself on building models
of a software system. These models are typically made manifest through
diagrammatic design notations - the UML is one option. 

The idea is
that you use these diagrams, to specify your system to a modeling tool
and then you generate code in a conventional programming language.
[[MDAfigure_01.jpg][bThe MDA process]] 

** PIM

A platform independent model describes the system, but does not
show details of its use of its platform.

A PIM might consist of enterprise, information and computational ODP viewpoint
specifications. (The structure of this information model might be quite different from
the structure of an information viewpoint model in a computation independent model
of the same system.)

A platform independent model will be suited for a particular architectural style, or
several.

[[fig364_01_0.jpg][PIM Sample]]

** PSM

A platform-specific model is a model of a software or business system
that is linked to a specific technological platform (e.g. a specific
programming language, operating system or database).

It should be
possible to use a MTL to transform a Platform-independent model into a
Platform-specific model.One PIM may have 1+ PSM.

[[fig369_01_0.jpg][PSM Sample]]


** Profiles

Profiles are a UML extension mechanism. A profile applies to a language
specification, specifying a new modeling language by adding new kinds of language
elements or restricting the language.

 - Stereotype
 - Constraint
 - Tagged value
 
* How MDA Helps Us

 1. Productivity
 2. Portability
   [[mda_dsl1.jpg]] 
 3. Interoperability

 4. Maintenance and Documentation  


*   [[http://maven.apache.org/][Maven]]  Introduction

Maven's primary goal is to allow a developer to comprehend the
complete state of a development effort in the shortest period of
time. In order to attain this goal there are several areas of concern
that Maven attempts to deal with: 

    - Making the build process easy
    - Providing a uniform build system
    - Providing quality project information
    - Providing guidelines for best practices development
    - Allowing transparent migration to new features

*   [[http://velocity.apache.org/][Velocity]]

Velocity is a simple yet powerful Java-based template engine that
renders data from plain Java objects to text, xml, email, SQL, Post
Script, HTML etc. The template syntax and rendering engine are both
easy to understand and quick to learn and implement.

<src>

DROP TABLE ${table.getSchema()}.${table.getName()}
@
CREATE TABLE ${table.getSchema()}.${table.getName()}
(

#foreach($col in ${table.getColumns()})
    , ${col.getColumnDef()}
#end

)
    IN ${table.getSchema()}_DATA_01
    INDEX IN ${table.getSchema()}_INDX_01
@

</src>

*   [[http://www.andromda.org/][Andromda ]]

[[andromdaarchjava.jpg]]

** Core Features 
AndroMDA currently comes with the following features:

   - Modular design: all major building blocks of AndroMDA are pluggable and can be exchanged to meet your needs
   - Support for major UML tools like MagicDraw, Poseidon, Enterprise Architect and more
   - Comes with the complete UML 1.4 metamodel (support for UML 2.0 is currently being developed) - alternatively, you can bring your own metamodel in MOF XMI and generate code from models based on it
   - Validates the input models using OCL constraints which are related to the metamodel classes. Comes with pre-configured constraints that protect you against the most common modeling mistakes - add your own project-specific constraints, too.
   - Model-to-model transformations help to raise abstraction level. Write your own transformations, currently in Java, or in any transformation language, e.g. the QVT-like Atlas Transformation Language (ATL), in the next major AndroMDA release.
   - Can generate any kind of text output using templates (source code, database scripts, web pages, O/R mapping configuration files, etc.) -  you teach it, AndroMDA does it!
   - Templates are based on well-known template engines. Currently, Velocity and FreeMarker are supported
   - Ready-to-use cartridges for common enterprise architectures (EJB, Spring, Hibernate, Struts, JSF, Axis, jBPM)
    

** Cartridges  	  
Very much like Eclipse, AndroMDA features a plug-in
architecture. AndroMDA itself basically is a transformation engine. To
support arbitrary target architectures, you can plug-in custom
transformations. These transformations are packaged as so-called
cartridges. 

AndroMDA comes with a host of ready-to-use cartridges such as:

  - Spring
  - EJB 2 / 3
  - Webservices
  - Hibernate
  - Struts
  - JSF
  - Java
  - XSD


** When to use AndroMDA?

AndroMDA is a great choice when

   -  You are starting a new project
   -  You want to save time by generating as much code as possible
   -  You are building an application that stores its data in a database

AndroMDA might not be the best choice if

    - Your application uses an existing database that cannot be easily mapped to an object model (for example, it does not use
      primary keys and object relationships are not clear) 
    - You already have a mature application with existing business objects and the incremental effort to model existing components
      is too high to provide enough value 

** Create Project

<src>

C:\>mvn org.andromda.maven.plugins:andromdapp-maven-plugin:3.2:generate
Please choose the type of application to generate [richclient, j2ee]
j2ee
Please enter the location in which your new application will be created
(i.e. f:/java/development):
C:/
Please enter your first and last name (i.e. Chad Brandon):
Naresh Bhatia
Which kind of modeling tool will you use? [uml1.4, uml2, emf-uml2]:
Use the list below to enter the correct choice:
    ArgoUML:        uml1.4
    MagicDraw 9.x:  uml1.4
    MagicDraw 11.5: uml2
    RSM 6:          emf-uml2
uml1.4

Please enter the name of your J2EE project (i.e. Animal Quiz):
TimeTracker

Please enter an id for your J2EE project (i.e. animalquiz):
timetracker

Please enter a version for your project (i.e. 1.0-SNAPSHOT):
1.0-SNAPSHOT

Please enter the root package name for your J2EE project
(i.e. org.andromda.samples.animalquiz):
org.andromda.timetracker

Would you like an EAR or standalone WAR? [ear, war]:
ear

Please enter the type of transactional/persistence cartridge to use
[hibernate, ejb, ejb3, spring, none]:
spring

Please enter the database backend for the persistence layer
[hypersonic, mysql, oracle, db2, informix, mssql, pointbase,
 postgres, sybase, sabdb, progress, derby]:
mysql

Will your project need workflow engine capabilities?
(it uses jBPM and Hibernate3)? [yes, no]:
no

Please enter the hibernate version number
(enter '2' for 2.1.x or '3' for 3.0.x) [2, 3]:
3

Will your project have a web user interface? [yes, no]:
yes

Would you like your web user interface to use JSF or Struts? [jsf, struts]:
struts

Would you like to be able to expose your services as web services? [yes, no]:
no
</src>

** Project Layout 
<src>
timetracker
     |
     |-- mda
     |
     |-- common
     |
     |-- core
     |
     |-- web
     |
     +-- app
    
</src>



** CRUD    

[[user.jpg]]

[[searchresultspanel2.jpg]]

** Page Flow

[[searchtimecardsuc.jpg]]

[[searchtimecardsad3.jpg]]

[[searchcriteriapanel.jpg]]

* [[http://www.martinfowler.com/dslwip/][DSL Introduction]]

The basic idea of a domain specific language (DSL) is a computer
language that's targeted to a particular kind of problem, rather than
a general purpose language that's aimed at any kind of software
problem. 

Domain specific languages have been talked about, and used
for almost as long as computing has been done. DSLs are very common in
computing.
<src>
      graphviz               LINQ
 ant
                  rake      Hibernate query language
        regular expression
                                 FIT
SQL                                         make
                   struts-config.xml
           CSS
                               rails validation
     JMock expectations

</src>

** Internal and External DSLs.

 - Internal DSLs are particular ways of using a host language to give the host
language the feel of a particular language. This approach has recently
been popularized by the Ruby community although it's had a long
heritage in other languages - in particular Lisp. Although it's
usually easier in low-ceremony languages like that, you can do
effective internal DSLs in more mainstream languages like Java and
C#. 

 - External DSLs have their own custom syntax and you
write a full parser to process them. There is a very strong tradition
of doing this in the Unix community. Many XML configurations have
ended up as external DSLs, although XML's syntax is badly suited to
this purpose. The most most common DSLs in the wild today are textual,
but you can have graphical DSLs too. Graphical DSLs requires a tool
along the lines of a Language Workbench. Language Workbenches are less
common but many people think they have the potential to profoundly
improve the way we do programming. DSLs can be implemented either by
interpretation or code generation. Interpretation (reading in the DSL
script and executing it at run time) is usually easiest, but
code-generation is sometimes essential. Usually the generated code is
itself a high level language, such as Java or C. 


* How DSL Helps Us

 1. Productivity
 2. Portability
 3. Interoperability
 4. Maintenance and Documentation  

*  [[http://www.ruby-lang.org/en/][Ruby]]

 - OOP
<src>
java: int c = Math.abs(-166);
ruby: c = -166.abs
</src>

 - Code Block
<src>
def callBlock
   yield
   yield
end
callBlock { puts "In the block" }

out:
 In the block
 In the block

</src>
 - [[http://www.innovationontherun.com/why-rubys-mixins-gives-rails-an-advantage-over-java-frameworks/][Mixin]]

<src>
module BarModule
  def hello_world
    puts "Hello World"
  end
end

class BaseClass
  def class_method
    puts "In class method"
  end
end

class Foo < BaseClass
  include BarModule
end
</src>
f = Foo.new | f = Foo.send(:new)
f.class_method | f.send(:class_method)
f.hello_world |  f.send(:hello_world)
<src>
String.send(:include, BarModule)
s = "Arbitrary String"
s.hello_world
</src>



** DSL in Ruby

<src lang="ruby">
class QuoteDSLBuilder

def self.load( dsl)

    proj = proj.instance_eval(File.read(dsl), dsl)
    proj
end

def create_quote(lob, cntry)
    ...
    yield
end

def tab (name) end
def select_customer custNum  end
def add_parts(partNum) end
def change_quantity(partNum, quantity) end
def recalculate_quote end
end#class QuoteDSLBuilder
</src>

** DSL in Ruby
<src lang="ruby">
create_quote 'PAUN','USA' do
  tab "Customers and partners" do
    select_customer '0007229725'
  end
    
  tab "Parts and pricing" do
    add_parts 'D576HLL','BB0PWNA'
    change_quantity 'D576HLL', 10
    recalculate_quote
    assert_parts_date 'D576HLL'
  end
end
</src>

*   [[http://www.rubyonrails.org/][Rails]]
<src>
work> rails depot
work> cd depot
depot> ls -p
README         components/ doc/ public/ tmp/
Rakefile       config/     lib/ script/ vendor/
app/           db/         log/ test/
</src>

** Create Model

<src>
depot> ruby script/generate model Product
  create db/migrate/001_create_products.rb

class CreateProducts < ActiveRecord::Migration
  def self.up
    create_table :products do |t|
      t.column :title,       :string
      t.column :description, :text
      t.column :image_url,   :string
    end
  end
  def self.down
    drop_table :products
  end
end
</src>
**  Create Controller
<src lang="rby">
depot> ruby script/generate controller admin
  create app/controllers/admin_controller.rb

class AdminController < ApplicationController
  scaffold :product
end

</src>

** Web UI

[[rails1.png]]

[[rails2.png]]

[[rails3.png]]



** The Advantages of MDA

 - The productivity increases because the programmers only have to model
the system and do a few customizations. 

 - The PIM can be used for more platforms. If you decide to change from
platform that shouldn't be a problem (theoretically). 

 - All the bridges between the different PSMs are automatically
generated. 

 - If you only have some pieces of your application modeled you'll be
able to do prototyping. All you have to do is to push the "Generate
code" button. 

 

** The Disadvantages of MDA

 - The MDA tools which are nowadays on the market aren't able to generate
100% code. So you'll always have to code after the generation process

 - If you want to use a relatively new technology, then you must keep in mind that the MDA tool is the developer
for you. So it takes some time before the producer has implemented a
new technology into their MDA tool.  
 - MDA need IDE support(version control etc...).
 - UML is not easy to read and cooperate.



** The Advantages of DSL

 -  Domain-specific languages allow solutions to be expressed in the
idiom and at the level of abstraction of the problem
domain. Consequently, domain experts themselves can understand,
validate, modify, and often even develop domain-specific language
programs. 
 -  Self-documenting code.
 -  Domain-specific languages enhance quality, productivity,
reliability, maintainability, portability and reusability. 
 - Domain-specific languages allow validation at the domain
level. As long as the language constructs are safe any sentence
written with them can be considered safe. 

** The Disadvantages of DSL

 - Cost of designing, implementing, and maintaining a domain-specific language.
 - Difficulty of balancing trade-offs between domain-specificity
 and general-purpose programming language constructs. 
 - Potential loss of processor efficiency compared with hand-coded
 software. 
 - Hard or impossible to debug.

#title MDA vs DSL

http://news.csdn.net/n/20080606/116568.html
http://subject.csdn.net/agile_dsl.htm


#标题： MDA vs DSL

* 软件开发中的问题

 1. 开发效率：希望软件能在最短时间里开发完成
 2. 可移植性：能够很容易的迁移到新的技术和平台上
 3. 维护和文档：希望软件易于维护，有最新的文档可以查阅

* MDA 介绍

相对于传统的软件开发，模型驱动软件开发方式是一种新的软件开发方式。它关注与构建软件系统的模型，这些模型用图形的方式展示，最常用的是
UML. 

具体做法是：你使用建模工具为系统建模，然后使用特定的编程语言生成程序代码。
 

** PIM （ Platform independent model 平台无关模型）

PIM 只描述系统模型，不涉及系统使用的平台的细节信息。

** PSM（Platform-specific model 平台相关模型）

PSM中会指定系统的编程语言，操作系统以及数据库等。

** Profiles

Profiles 是UML的扩展机制。一个Profile对应一种编程约定。

 - 模板：Stereotype
 - 约束：Constraint
 - 标签：Tagged value

** MDA如何帮助我们

 1. 开发效率：帮助我们生成了大量代码，去除了无谓的拷贝粘贴，提高了效率，减少了出错机会。
 2. 可移植性：可以生成基于不同编程语言，操作系统和数据的代码，为移植带来了很大的便利
 3. 维护和文档：只有少数代码是手动编写，而且代码都是符合统一风格，易于维护。模型总是最新的，通过可视化的模型，开发人员能更方便的了
    解系统。


* Andromda 介绍


[[andromdaarchjava.jpg]]

** 由三部分组成：
 1. Generic code generation engine 代码生成引擎
 2. Cartridges (Java, EJB, Hibernate, Spring, JSF, Struts, etc.) 插件
 3. Tools 辅助工具
 - Maven project generator
 - Schema2XMI

** 代码生成率：

 - 持久层Persistence (EJB/Hibernate): 100%
 - 业务层Business (EJB): 30%
 - WebServices (Axis): 100%
 - 表现层Presentation (Struts): 80%

** 开发流程：

 - 生成项目: maven andromdapp:generate
 - 编辑模型
 - 编译: maven
 - 编写具体实现

** 何时使用 Andromda

*** 在以下情况适合使用：

 - 开始创建一个新项目
 - 希望能够尽量多的自动生成代码

*** 在以下情况不适合使用：

 - 系统的数据结构不能很好的映射到对象。例如，没有主键和对象间的关系
 - 你已经拥有一个成熟的系统，为这个系统建模的工作量太大，且不能带来足够的好处

** Demo

*** 创建项目

<src>

C:\>mvn org.andromda.maven.plugins:andromdapp-maven-plugin:3.2:generate
Please choose the type of application to generate [richclient, j2ee]
j2ee
Please enter the location in which your new application will be created
(i.e. f:/java/development):
C:/
Please enter your first and last name (i.e. Chad Brandon):
Naresh Bhatia
Which kind of modeling tool will you use? [uml1.4, uml2, emf-uml2]:
Use the list below to enter the correct choice:
    ArgoUML:        uml1.4
    MagicDraw 9.x:  uml1.4
    MagicDraw 11.5: uml2
    RSM 6:          emf-uml2
uml1.4

Please enter the name of your J2EE project (i.e. Animal Quiz):
TimeTracker

Please enter an id for your J2EE project (i.e. animalquiz):
timetracker

Please enter a version for your project (i.e. 1.0-SNAPSHOT):
1.0-SNAPSHOT

Please enter the root package name for your J2EE project
(i.e. org.andromda.samples.animalquiz):
org.andromda.timetracker

Would you like an EAR or standalone WAR? [ear, war]:
ear

Please enter the type of transactional/persistence cartridge to use
[hibernate, ejb, ejb3, spring, none]:
spring

Please enter the database backend for the persistence layer
[hypersonic, mysql, oracle, db2, informix, mssql, pointbase,
 postgres, sybase, sabdb, progress, derby]:
mysql

Will your project need workflow engine capabilities?
(it uses jBPM and Hibernate3)? [yes, no]:
no

Please enter the hibernate version number
(enter '2' for 2.1.x or '3' for 3.0.x) [2, 3]:
3

Will your project have a web user interface? [yes, no]:
yes

Would you like your web user interface to use JSF or Struts? [jsf, struts]:
struts

Would you like to be able to expose your services as web services? [yes, no]:
no
</src>

*** 项目结构
<src>
timetracker
     |
     |-- mda
     |
     |-- common
     |
     |-- core
     |
     |-- web
     |
     +-- app
    
</src>


*** 增删查改

[[user.jpg]]

[[searchresultspanel2.jpg]]

*** 页面流

[[searchtimecardsuc.jpg]]

[[SearchControllerToUserService.jpg]]

[[searchtimecardsad3.jpg]]

[[searchcriteriapanel.jpg]]




* DSL 介绍

DSL （Domain Specific Language)是一种针对特殊问题的编程语言，不是那种可以编写各种应用，解决多种问题的通用编程语言。

DSL已经在计算机领域使用了很久了，是非常普遍的。

<src>
      graphviz               LINQ
 ant
                  rake      Hibernate query language
        regular expression
                                 FIT
SQL                                         make
                   struts-config.xml
           CSS
                               rails validation
     JMock expectations

</src>

** Internal and External DSLs.

 - Internal DSLs: 是对编程语言的一种特殊用法。在ruby语言里特别流行。但是，在Lisp, Java和C#中同样可以实现 internal DSLs.
 - External DSLs: 其拥有特殊的语法，需要一个程序去分析和处理它。很多XML配置文件就是 external DSLs. 现在使用的最多的是文本格式的
   DSLs，但是，我们同样可以有图形化的DSLs. 有两种方式实现DSLs：解析方式（读入DLS脚本，然后动态执行）；代码生成方式。

** DSL如何帮助我们解决问题

 1. 开发效率：可以让我们编写更少的代码实现更多的功能。帮助我们生成了大量代码，去除了无谓的拷贝粘贴，提高了效率，减少了出错机会。
 2. 可移植性：具有一定的平台移植性。
 3. 维护和文档：代码更易阅读，代码本身就是最好的文档。

*  [[http://www.ruby-lang.org/en/][Ruby]] 介绍

 - OOP
<src>
java: int c = Math.abs(-166);
ruby: c = -166.abs
</src>

 - Code Block
<src>
def callBlock
   yield
   yield
end
callBlock { puts "In the block" }

out:
 In the block
 In the block

</src>
 - [[http://www.innovationontherun.com/why-rubys-mixins-gives-rails-an-advantage-over-java-frameworks/][Mixin]]

<src>
module BarModule
  def hello_world
    puts "Hello World"
  end
end

class BaseClass
  def class_method
    puts "In class method"
  end
end

class Foo < BaseClass
  include BarModule
end
</src>
f = Foo.new | f = Foo.send(:new)
f.class_method | f.send(:class_method)
f.hello_world |  f.send(:hello_world)
<src>
String.send(:include, BarModule)
s = "Arbitrary String"
s.hello_world
</src>



** DSL in Ruby

<src lang="ruby">
class QuoteDSLBuilder

def self.load( dsl)

    proj = proj.instance_eval(File.read(dsl), dsl)
    proj
end

def create_quote(lob, cntry)
    ...
    yield
end

def tab (name) end
def select_customer custNum  end
def add_parts(partNum) end
def change_quantity(partNum, quantity) end
def recalculate_quote end
end#class QuoteDSLBuilder
</src>


<src lang="ruby">
create_quote 'PAUN','USA' do
  tab "Customers and partners" do
    select_customer '0007229725'
  end
    
  tab "Parts and pricing" do
    add_parts 'D576HLL','BB0PWNA'
    change_quantity 'D576HLL', 10
    recalculate_quote
    assert_parts_date 'D576HLL'
  end
end
</src>

***   [[http://www.rubyonrails.org/][Rails]]
<src>
work> rails depot
work> cd depot
depot> ls -p
README         components/ doc/ public/ tmp/
Rakefile       config/     lib/ script/ vendor/
app/           db/         log/ test/
</src>

**** Create Model

<src>
depot> ruby script/generate model Product
  create db/migrate/001_create_products.rb

class CreateProducts < ActiveRecord::Migration
  def self.up
    create_table :products do |t|
      t.column :title,       :string
      t.column :description, :text
      t.column :image_url,   :string
    end
  end
  def self.down
    drop_table :products
  end
end
</src>
****  Create Controller
<src lang="rby">
depot> ruby script/generate controller admin
  create app/controllers/admin_controller.rb

class AdminController < ApplicationController
  scaffold :product
end

</src>

* MDA和DSL比较

** MDA的优点

 - 因为只需要建模和少量的定制就可以开发出应用系统，生产效率提高了
 - 理论上，很容易迁移到其他平台
 - 易于做原型，点一下“生产代码”按钮就可以了

** MDA的缺点

 - 现在市场上的MDA工具还不能生成100%的代码，所以你必须在代码生成后手动修改代码
 - 如果你要使用最新技术，你要么自己实现插件，要么等到别人实现
 - MDA需要工具支持
 - UML 不是易读和协作

** DSL的优点

 - DSL可以对问题做更高的抽象，一次业务专家可以理解，验证甚至自己编写DSL
 - 代码就是注释
 - DSL提高的代码质量，开发效率，可维护性和可重用性
 
** DSL的缺点

 - 设计，实现和维护DSL需要一定的工作
 - 不好权衡何时使用DSL，何时使用同样编程语言
 - 执行效率可能会打折
 - 很难或根本无法debug

